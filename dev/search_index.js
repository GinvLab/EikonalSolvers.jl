var documenterSearchIndex = {"docs":
[{"location":"privatestuff/#Don't-use-these...","page":"Private stuff","title":"Don't use these...","text":"","category":"section"},{"location":"privatestuff/#EikonalSolvers","page":"Private stuff","title":"EikonalSolvers","text":"","category":"section"},{"location":"privatestuff/#EikonalSolvers.bilinear_interp-Tuple{AbstractMatrix{Float64}, EikonalSolvers.AbstractGridEik2D, AbstractVector{Float64}}","page":"Private stuff","title":"EikonalSolvers.bilinear_interp","text":"bilinear_interp(\n    f::AbstractMatrix{Float64},\n    grd::EikonalSolvers.AbstractGridEik2D,\n    xyzpt::AbstractVector{Float64};\n    outputcoeff\n) -> Any\n\n\nBilinear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.calc2diagDttD-Tuple{EikonalSolvers.VecSPDerivMat, Vector{Float64}, Vector{Bool}}","page":"Private stuff","title":"EikonalSolvers.calc2diagDttD","text":"calc2diagDttD(\n    vecD::EikonalSolvers.VecSPDerivMat,\n    tt::Vector{Float64},\n    onsrccols::Vector{Bool}\n) -> Tuple{EikonalSolvers.VecSPDerivMat, SparseArrays.SparseMatrixCSC{Float64, Int64}}\n\n\nCalculates the following maintaining the sparse structure:      2 * diag(D * tt) * Dr\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.calc_dus_dsr-Union{Tuple{N}, Tuple{AbstractArray{Float64}, Array{Float64, N}, AbstractVector{Float64}, Any, EikonalSolvers.AbstractGridEik, Vector{Float64}}} where N","page":"Private stuff","title":"EikonalSolvers.calc_dus_dsr","text":"calc_dus_dsr(\n    lambda_coarse::AbstractArray{Float64},\n    velcart_coarse::Array{Float64, N},\n    ∂ψ_∂u_s::AbstractVector{Float64},\n    srcboxpar_coarse,\n    grd::EikonalSolvers.AbstractGridEik,\n    xyzsrc::Vector{Float64}\n) -> Any\n\n\nCalculates the derivative of the misfit function with respect to the traveltime at the initial points around the source (\"onsrc\").\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.calcgradsomesrc-Union{Tuple{N}, Tuple{Array{Float64, N}, AbstractMatrix{Float64}, AbstractVector{Matrix{Float64}}, EikonalSolvers.AbstractGridEik, AbstractVector{Vector{Float64}}, AbstractVector{Vector{Float64}}, Symbol, ExtraParams}} where N","page":"Private stuff","title":"EikonalSolvers.calcgradsomesrc","text":"calcgradsomesrc(\n    vel::Array{Float64, N},\n    xyzsrc::AbstractMatrix{Float64},\n    coordrec::AbstractVector{Matrix{Float64}},\n    grd::EikonalSolvers.AbstractGridEik,\n    stdobs::AbstractVector{Vector{Float64}},\n    pickobs1::AbstractVector{Vector{Float64}},\n    whichgrad::Symbol,\n    extrapars::ExtraParams\n) -> Tuple{Any, Any, Float64}\n\n\nCalculate the gradient for some requested sources \n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.calcprojttfmmord-Union{Tuple{N}, Tuple{AbstractArray{Float64, N}, EikonalSolvers.AbstractGridEik, EikonalSolvers.MapOrderGridFMM, AbstractArray{Float64}}} where N","page":"Private stuff","title":"EikonalSolvers.calcprojttfmmord","text":"calcprojttfmmord(\n    ttime::AbstractArray{Float64, N},\n    grd::EikonalSolvers.AbstractGridEik,\n    idxconv::EikonalSolvers.MapOrderGridFMM,\n    coordrec::AbstractArray{Float64}\n) -> Any\n\n\nProjection operator P containing interpolation coefficients, ordered according to FMM order.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.calcttpt_2ndord!-Tuple{EikonalSolvers.FMMVars2D, Matrix{Float64}, EikonalSolvers.AbstractGridEik2D, StaticArraysCore.MVector{2, Int64}, StaticArraysCore.MVector{2, <:Integer}}","page":"Private stuff","title":"EikonalSolvers.calcttpt_2ndord!","text":"calcttpt_2ndord!(\n    fmmvars::EikonalSolvers.FMMVars2D,\n    vel::Matrix{Float64},\n    grd::EikonalSolvers.AbstractGridEik2D,\n    ij::StaticArraysCore.MVector{2, Int64},\n    codeD::StaticArraysCore.MVector{2, <:Integer}\n) -> Any\n\n\nCompute the traveltime at a given node using 2nd order stencil      where possible, otherwise revert to 1st order.     Two-dimensional Cartesian or spherical grid.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.calcttpt_2ndord!-Tuple{EikonalSolvers.FMMVars3D, Array{Float64, 3}, EikonalSolvers.AbstractGridEik3D, StaticArraysCore.MVector{3, Int64}, StaticArraysCore.MVector{3, <:Integer}}","page":"Private stuff","title":"EikonalSolvers.calcttpt_2ndord!","text":"calcttpt_2ndord!(\n    fmmvars::EikonalSolvers.FMMVars3D,\n    vel::Array{Float64, 3},\n    grd::EikonalSolvers.AbstractGridEik3D,\n    ijk::StaticArraysCore.MVector{3, Int64},\n    codeD::StaticArraysCore.MVector{3, <:Integer}\n) -> Any\n\n\nCompute the traveltime at a given node using 2nd order stencil      where possible, otherwise revert to 1st order.     Three-dimensional Cartesian or spherical grid.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.distribsrcs-Tuple{Integer, Integer}","page":"Private stuff","title":"EikonalSolvers.distribsrcs","text":"distribsrcs(nsrc::Integer, nw::Integer) -> Any\n\n\nCalculate how to subdivide the sources among workers for parallel jobs.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.findclosestnode_sph-NTuple{6, Float64}","page":"Private stuff","title":"EikonalSolvers.findclosestnode_sph","text":"findclosestnode_sph(\n    r::Float64,\n    θ::Float64,\n    rinit::Float64,\n    θinit::Float64,\n    Δr::Float64,\n    Δθ::Float64\n) -> Tuple{Int64, Int64}\n\n\nFind closest node on a 2D grid to a given point in spherical/polar coordinates.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.findclosestnode_sph-NTuple{9, Float64}","page":"Private stuff","title":"EikonalSolvers.findclosestnode_sph","text":"findclosestnode_sph(\n    r::Float64,\n    θ::Float64,\n    φ::Float64,\n    rinit::Float64,\n    θinit::Float64,\n    φinit::Float64,\n    Δr::Float64,\n    Δθ::Float64,\n    Δφ::Float64\n) -> Tuple{Int64, Int64, Int64}\n\n\nFind closest node on a 3D grid to a given point in spherical coordinates.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.findenclosingbox-Tuple{EikonalSolvers.AbstractGridEik, AbstractVector}","page":"Private stuff","title":"EikonalSolvers.findenclosingbox","text":"findenclosingbox(\n    grd::EikonalSolvers.AbstractGridEik,\n    xyzsrc::AbstractVector\n) -> AbstractMatrix{<:Int64}\n\n\nFind closest node on a grid to a given point.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.gaussian_kernel-Tuple{Integer, Integer}","page":"Private stuff","title":"EikonalSolvers.gaussian_kernel","text":"Gaussian kernel for smoothing\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.isonbord-NTuple{4, Int64}","page":"Private stuff","title":"EikonalSolvers.isonbord","text":"isonbord(\n    ib::Int64,\n    jb::Int64,\n    n1::Int64,\n    n2::Int64\n) -> Tuple{Bool, Bool}\n\n\nTest if point is on borders of 2D domain.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.isonbord-NTuple{6, Int64}","page":"Private stuff","title":"EikonalSolvers.isonbord","text":"isonbord(\n    ib::Int64,\n    jb::Int64,\n    kb::Int64,\n    nx::Int64,\n    ny::Int64,\n    nz::Int64\n) -> Tuple{Bool, Bool}\n\n\nTest if point is on borders of a 3D domain.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.setcoeffderiv!-Tuple{EikonalSolvers.VecSPDerivMat, Array, Integer, EikonalSolvers.MapOrderGridFMM, Matrix{Int64}, EikonalSolvers.CoeffDerivatives, AbstractVector, AbstractVector{Int64}, AbstractVector{Float64}, AbstractVector{Int64}, Integer}","page":"Private stuff","title":"EikonalSolvers.setcoeffderiv!","text":"setcoeffderiv!(\n    D::EikonalSolvers.VecSPDerivMat,\n    status::Array,\n    irow::Integer,\n    idxconv::EikonalSolvers.MapOrderGridFMM,\n    codeDeriv_orig::Matrix{Int64},\n    allcoeff::EikonalSolvers.CoeffDerivatives,\n    ijkpt::AbstractVector,\n    colinds::AbstractVector{Int64},\n    colvals::AbstractVector{Float64},\n    idxperm::AbstractVector{Int64},\n    nptsfixedtt::Integer;\n    axis,\n    simtype\n)\n\n\nSet the coefficients (elements) of the derivative matrices in the x and y directions.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.smoothgradient-Tuple{Any, Any}","page":"Private stuff","title":"EikonalSolvers.smoothgradient","text":"Smooth gradient for arrays of any dimensions.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.smoothimg-Tuple{Any, Any}","page":"Private stuff","title":"EikonalSolvers.smoothimg","text":"Smooth an array of any dimension\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.sourceboxloctt!-Union{Tuple{N}, Tuple{EikonalSolvers.AbstractFMMVars, Array{Float64, N}, AbstractVector, EikonalSolvers.AbstractGridEik}} where N","page":"Private stuff","title":"EikonalSolvers.sourceboxloctt!","text":"sourceboxloctt!(\n    fmmvars::EikonalSolvers.AbstractFMMVars,\n    vel::Array{Float64, N},\n    srcpos::AbstractVector,\n    grd::EikonalSolvers.AbstractGridEik\n)\n\n\nDefine the \"box\" of nodes around/including the source.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.tracerays_singlesrc-Union{Tuple{N}, Tuple{EikonalSolvers.AbstractGridEik, Array{Float64, N}, AbstractVector, Matrix{Float64}}} where N","page":"Private stuff","title":"EikonalSolvers.tracerays_singlesrc","text":"tracerays_singlesrc(\n    grd::EikonalSolvers.AbstractGridEik,\n    ttime::Array{Float64, N},\n    srccoo::AbstractVector,\n    coordrec::Matrix{Float64};\n    steplen\n)\n\n\nRay tracing utility. Given a traveltime grid and source and receiver positions, trace the rays.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.trilinear_interp-Tuple{AbstractArray{Float64, 3}, EikonalSolvers.AbstractGridEik3D, AbstractVector{Float64}}","page":"Private stuff","title":"EikonalSolvers.trilinear_interp","text":"trilinear_interp(\n    f::AbstractArray{Float64, 3},\n    grd::EikonalSolvers.AbstractGridEik3D,\n    xyzpt::AbstractVector{Float64};\n    outputcoeff\n) -> Any\n\n\nTrinilear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.ttFMM_core!-Union{Tuple{N}, Tuple{EikonalSolvers.AbstractFMMVars, Array{Float64, N}, EikonalSolvers.AbstractGridEik, Union{Nothing, EikonalSolvers.AbstractAdjointVars}}} where N","page":"Private stuff","title":"EikonalSolvers.ttFMM_core!","text":"ttFMM_core!(\n    fmmvars::EikonalSolvers.AbstractFMMVars,\n    vel::Array{Float64, N},\n    grd::EikonalSolvers.AbstractGridEik,\n    adjvars::Union{Nothing, EikonalSolvers.AbstractAdjointVars};\n    fmmvars_coarse,\n    adjvars_coarse,\n    srcrefvars\n)\n\n\nHigher order (2nd) fast marching method in 2D using traditional stencils on regular grid. \n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.ttforwsomesrc-Union{Tuple{N}, Tuple{Array{Float64, N}, Matrix{Float64}, Vector{Matrix{Float64}}, EikonalSolvers.AbstractGridEik, ExtraParams}} where N","page":"Private stuff","title":"EikonalSolvers.ttforwsomesrc","text":"ttforwsomesrc(\n    vel::Array{Float64, N},\n    coordsrc::Matrix{Float64},\n    coordrec::Vector{Matrix{Float64}},\n    grd::EikonalSolvers.AbstractGridEik,\n    extrapars::ExtraParams;\n    returntt\n) -> Union{Tuple{Vector{Array{Float64}}, Vector{Vector{Float64}}}, Vector{Vector{Float64}}}\n\n\nCompute the forward problem for a group of sources.\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.uniform_kernel-Tuple{Integer, Integer}","page":"Private stuff","title":"EikonalSolvers.uniform_kernel","text":"Uniform kernel for smoothing\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#Binary-heap(s)","page":"Private stuff","title":"Binary heap(s)","text":"","category":"section"},{"location":"privatestuff/#EikonalSolvers.BinHeaps","page":"Private stuff","title":"EikonalSolvers.BinHeaps","text":"Binary heaps (min/max)\n\n IMPORTANT: make sure the handle is unique!\n  Check is commented out because it slows things down...\n\nExports\n\nBinHeapMax\nBinHeapMin\nbuild_maxheap!\nbuild_minheap!\ninit_maxheap\ninit_minheap\ninsert_maxheap!\ninsert_minheap!\npop_maxheap!\npop_minheap!\ntopval_heap\nupdate_node_maxheap!\nupdate_node_minheap!\n\n\n\n\n\n","category":"module"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.BinHeapMax","page":"Private stuff","title":"EikonalSolvers.BinHeaps.BinHeapMax","text":"struct BinHeapMax\n\nFields\n\nNmax::Int64\nNh::Base.RefValue{Int64}\nnodes::Vector{Float64}\nhandles::Vector{Int64}\nidxhan::Vector{Int64}\n\n\n\n\n\n","category":"type"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.BinHeapMin","page":"Private stuff","title":"EikonalSolvers.BinHeaps.BinHeapMin","text":"struct BinHeapMin\n\nFields\n\nNmax::Int64\nNh::Base.RefValue{Int64}\nnodes::Vector{Float64}\nhandles::Vector{Int64}\nidxhan::Vector{Int64}\n\n\n\n\n\n","category":"type"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.build_maxheap!-Tuple{Vector{Float64}, Integer, Vector{Int64}}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.build_maxheap!","text":"build_maxheap!(\n    values::Vector{Float64},\n    Nmax::Integer,\n    handles::Vector{Int64}\n) -> EikonalSolvers.BinHeaps.BinHeapMax\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.build_minheap!-Tuple{Vector{Float64}, Integer, Vector{Int64}}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.build_minheap!","text":"build_minheap!(\n    values::Vector{Float64},\n    Nmax::Integer,\n    handles::Vector{Int64}\n) -> EikonalSolvers.BinHeaps.BinHeapMin\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.index_leftchild-Tuple{Integer}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.index_leftchild","text":"index_leftchild(i::Integer) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.index_parent-Tuple{Integer}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.index_parent","text":"index_parent(i::Integer) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.index_rightchild-Tuple{Integer}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.index_rightchild","text":"index_rightchild(i::Integer) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.init_maxheap-Tuple{Integer}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.init_maxheap","text":"init_maxheap(\n    Nmax::Integer\n) -> EikonalSolvers.BinHeaps.BinHeapMax\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.init_minheap-Tuple{Integer}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.init_minheap","text":"init_minheap(\n    Nmax::Integer\n) -> EikonalSolvers.BinHeaps.BinHeapMin\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.insert_maxheap!-Tuple{EikonalSolvers.BinHeaps.BinHeapMax, Float64, Int64}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.insert_maxheap!","text":"insert_maxheap!(\n    h::EikonalSolvers.BinHeaps.BinHeapMax,\n    val::Float64,\n    handle::Int64\n)\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.insert_minheap!-Tuple{EikonalSolvers.BinHeaps.BinHeapMin, Float64, Int64}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.insert_minheap!","text":"insert_minheap!(\n    h::EikonalSolvers.BinHeaps.BinHeapMin,\n    val::Float64,\n    handle::Int64\n)\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.max_heapify!-Tuple{EikonalSolvers.BinHeaps.BinHeapMax, Int64}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.max_heapify!","text":"max_heapify!(\n    h::EikonalSolvers.BinHeaps.BinHeapMax,\n    i::Int64\n)\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.pop_maxheap!-Tuple{EikonalSolvers.BinHeaps.BinHeapMax}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.pop_maxheap!","text":"pop_maxheap!(\n    h::EikonalSolvers.BinHeaps.BinHeapMax\n) -> Tuple{Int64, Float64}\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.pop_minheap!-Tuple{EikonalSolvers.BinHeaps.BinHeapMin}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.pop_minheap!","text":"pop_minheap!(\n    h::EikonalSolvers.BinHeaps.BinHeapMin\n) -> Tuple{Int64, Float64}\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.swap_nodes_heap!-Tuple{Union{EikonalSolvers.BinHeaps.BinHeapMax, EikonalSolvers.BinHeaps.BinHeapMin}, Integer, Integer}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.swap_nodes_heap!","text":"swap_nodes_heap!(\n    h::Union{EikonalSolvers.BinHeaps.BinHeapMax, EikonalSolvers.BinHeaps.BinHeapMin},\n    p::Integer,\n    q::Integer\n)\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.topval_heap-Tuple{Union{EikonalSolvers.BinHeaps.BinHeapMax, EikonalSolvers.BinHeaps.BinHeapMin}}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.topval_heap","text":"topval_heap(\n    h::Union{EikonalSolvers.BinHeaps.BinHeapMax, EikonalSolvers.BinHeaps.BinHeapMin}\n) -> Tuple{Float64, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.update_node_maxheap!-Tuple{EikonalSolvers.BinHeaps.BinHeapMax, Float64, Int64}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.update_node_maxheap!","text":"update_node_maxheap!(\n    h::EikonalSolvers.BinHeaps.BinHeapMax,\n    val::Float64,\n    handle::Int64\n)\n\n\n\n\n\n\n","category":"method"},{"location":"privatestuff/#EikonalSolvers.BinHeaps.update_node_minheap!-Tuple{EikonalSolvers.BinHeaps.BinHeapMin, Float64, Int64}","page":"Private stuff","title":"EikonalSolvers.BinHeaps.update_node_minheap!","text":"update_node_minheap!(\n    h::EikonalSolvers.BinHeaps.BinHeapMin,\n    val::Float64,\n    handle::Int64\n)\n\n\n\n\n\n\n","category":"method"},{"location":"publicapi/#API,-exported-functions","page":"API","title":"API, exported functions","text":"","category":"section"},{"location":"publicapi/#EikonalSolvers.EikonalSolvers","page":"API","title":"EikonalSolvers.EikonalSolvers","text":"EikonalSolvers\n\nEikonalSolvers module, 2D and 3D traveltime and gradient computations in Cartesian   and spherical coordinates.  Computes seismic traveltimes by solving the eikonal equation in two and three dimensions with the possibility of computing the gradient of the misfit function with respect to the velocity model.   Both forward and gradient computations are parallelised using Julia's distributed computing functions and the parallelisation is \"by source\", distributing calculations for different sources to different processors.\n\nExports\n\nEikonalProbSrcLoc\nEikonalProbVel\nEikonalProbVelAndSrcLoc\nExtraParams\nGrid2DCart\nGrid2DSphere\nGrid3DCart\nGrid3DSphere\nGridRefinementPars\neikgradient\neiktraveltime\neikttimemisfit\nsavemodelvtk\ntracerays\n\n\n\n\n\n","category":"module"},{"location":"publicapi/#Cartesian/spherical-grids-structures","page":"API","title":"Cartesian/spherical grids structures","text":"","category":"section"},{"location":"publicapi/#EikonalSolvers.Grid2DCart","page":"API","title":"EikonalSolvers.Grid2DCart","text":"struct Grid2DCart <: EikonalSolvers.AbstractGridEik2D\n\nA structure holding the 2D grid parameters, geometry and size.\n\nhgrid::Float64: Spacing of the grid nodes\ncooinit::Tuple{Float64, Float64}: Origin of the coodinates of the grid\ncooend::Tuple{Float64, Float64}: End of the coodinates of the grid\ngrsize::Tuple{Int64, Int64}: Number of grid nodes along x and y\nx::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}: x coordinates of the grid nodes\ny::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}: y coordinates of the grid nodes\n\nThe constructor requires three arguments (see the example):\n\nhgrid: spacing of the grid nodes\ncooinit: origin of the coordinate system\ngrsize: number of grid nodes along x and y\n\nExample\n\njulia> Grid2DCart(hgrid=5.0,cooinit=(0.0,0.0),grsize=(300,250))\n\n\n\n\n\n","category":"type"},{"location":"publicapi/#EikonalSolvers.Grid3DCart","page":"API","title":"EikonalSolvers.Grid3DCart","text":"struct Grid3DCart <: EikonalSolvers.AbstractGridEik3D\n\nA structure holding the 3D grid parameters, geometry and size.\n\nFields\n\nhgrid::Float64: Spacing of the grid nodes\ncooinit::Tuple{Float64, Float64, Float64}: Origin of the coodinates of the grid\ncooend::Tuple{Float64, Float64, Float64}: End of the coodinates of the grid\ngrsize::Tuple{Int64, Int64, Int64}: Number of grid nodes along x, y and z\nx::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}: x coordinates of the grid nodes\ny::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}: y coordinates of the grid nodes\nz::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}: z coordinates of the grid nodes\n\nThe constructor requires three arguments (see the example):\n\nhgrid: spacing of the grid nodes\ncooinit: origin of the coordinate system\ngrsize: number of grid nodes along x, y and z\n\nExample\n\njulia> Grid3DCart(hgrid=5.0,cooinit=(0.0,0.0,0.0),grsize=(60,60,40))\n\n\n\n\n\n","category":"type"},{"location":"publicapi/#EikonalSolvers.Grid2DSphere","page":"API","title":"EikonalSolvers.Grid2DSphere","text":"A structure holding the 2D SPHERICAL grid parameters, geometry and size.\n\nΔr::Float64: Spacing of the grid nodes along the radius (r)\nΔθ::Float64: Spacing of the grid nodes along the angle θ\ncooinit::Tuple{Float64, Float64}: Origin of the coodinates of the grid\ncooend::Tuple{Float64, Float64}: End of the coodinates of the grid\ngrsize::Tuple{Int64, Int64}: Number of grid nodes along r and θ\nr::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}: r coordinates of the grid nodes\nθ::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}: θ coordinates of the grid nodes\n\nThe fields are:    \n\nΔr: spacing of the grid nodes along the radial coordinate r\nΔθ: spacing of the grid nodes along the θ coordinate\ncooinit: origin of the coordinate system\ngrsize: number of grid nodes along r and θ \n\nExample\n\njulia> Grid2DSphere(Δr=15.0,Δθ=2.0,grsize=(10,15),cooinit=(500.0,0.0))\n\n\n\n\n\n","category":"type"},{"location":"publicapi/#EikonalSolvers.Grid3DSphere","page":"API","title":"EikonalSolvers.Grid3DSphere","text":"A structure holding the 3D SPHERICAL grid parameters, geometry and size.\n\nΔr::Float64: Spacing of the grid nodes along the radius (r)\nΔθ::Float64: Spacing of the grid nodes along the angle θ\nΔφ::Float64: Spacing of the grid nodes along the angle φ\ncooinit::Tuple{Float64, Float64, Float64}: Origin of the coodinates of the grid\ncooend::Tuple{Float64, Float64, Float64}: End of the coodinates of the grid\ngrsize::Tuple{Int64, Int64, Int64}: Number of grid nodes along r, θ and φ\nr::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}: r coordinates of the grid nodes\nθ::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}: θ coordinates of the grid nodes\nφ::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}: φ coordinates of the grid nodes\n\nThe fields are:    \n\nΔr: spacing of the grid nodes along the radial coordinate r\nΔθ: spacing of the grid nodes along the θ coordinate\nΔφ: spacing of the grid nodes along the θ coordinate\ncooinit: origin of the coordinate system\ngrsize: number of grid nodes along r, θ and φ \n\nExample\n\njulia> Grid3DSphere(Δr=15.0,Δθ=2.0,Δφ=1.5,grsize=(10,15,12),cooinit=(500.0,20.0,0.0))\n\n\n\n\n\n","category":"type"},{"location":"publicapi/#Forward,-gradient-and-misfit-calculation-functions","page":"API","title":"Forward, gradient and misfit calculation functions","text":"","category":"section"},{"location":"publicapi/#EikonalSolvers.eiktraveltime","page":"API","title":"EikonalSolvers.eiktraveltime","text":"eiktraveltime(\n    vel::Array{Float64, N},\n    grd::EikonalSolvers.AbstractGridEik,\n    coordsrc::Matrix{Float64},\n    coordrec::Vector{Matrix{Float64}};\n    returntt,\n    extraparams\n) -> Any\n\n\nCalculate the traveltime for 2D or 3D velocity models at requested receivers locations. Optionally return the array(s) of traveltime on the entire gridded model.\n\nArguments\n\nvel: the 2D or 3D velocity model \ngrd: a struct specifying the geometry and size of the model (e.g., Grid3DCart)\ncoordsrc: the coordinates of the source(s) (x,y), a 2-column array \ncoordrec: the coordinates of the receiver(s) (x,y) for each single source, a vector of 2-column arrays\nreturntt: a boolean (default false) specifying whether to retur the array(s) of traveltime on the entire gridded model or not\nextraparams (optional): a struct containing some \"extra\" parameters, namely\nparallelkind: serial, Threads or Distributed run? (:serial, :sharedmem, :distribmem)\nrefinearoundsrc: whether to perform a refinement of the grid around the source location\ngrdrefpars: refined grid around the source parameters (downscalefactor and noderadius)\nradiussmoothgradsrc: radius for smoothing each individual gradient only around the source. Zero means no smoothing.\nsmoothgradkern: smooth the final gradient with a kernel of size smoothgradkern (in grid nodes). Zero means no smoothing.\nmanualGCtrigger: trigger garbage collector (GC) manually at selected points.\n\nReturns\n\nA vector of vectors containing traveltimes at the receivers for each source \nIf returntt==true, additionally returns the array(s) of traveltime on the entire gridded model\n\n\n\n\n\n","category":"function"},{"location":"publicapi/#EikonalSolvers.eikgradient","page":"API","title":"EikonalSolvers.eikgradient","text":"eikgradient(\n    vel::Array{Float64, N},\n    grd::EikonalSolvers.AbstractGridEik,\n    coordsrc::Matrix{Float64},\n    coordrec::Vector{Matrix{Float64}},\n    pickobs::Vector{Vector{Float64}},\n    stdobs::Vector{Vector{Float64}},\n    whichgrad::Symbol;\n    extraparams\n) -> Union{Nothing, Tuple{Any, Any}, Tuple{Any, Any, Any}}\n\n\nCalculate the gradient of the misfit function w.r.t. either velocity or source location (or both) using the adjoint state method for 2D or 3D problems. \n\nThe computations may be run in parallel depending on the value of extraparams.parallelkind.\n\nArguments\n\nvel: the 2D or 3D velocity model \ngrd: a struct specifying the geometry and size of the model (e.g., Grid3DCart)\ncoordsrc: the coordinates of the source(s) (x,y), a 2-column array \ncoordrec: the coordinates of the receiver(s) (x,y) for each single source, a vector of 2-column arrays \npickobs: observed traveltime picks\nstdobs: standard deviation of error on observed traveltime picks, an array with same shape than pickobs\nwhichgrad: one of :gradvel, :gradsrcloc, :gradvelandsrcloc, specifies which gradient should be computed\nextraparams (optional): a struct containing some \"extra\" parameters, namely\nparallelkind: serial, Threads or Distributed run? (:serial, :sharedmem, :distribmem)\nrefinearoundsrc: whether to perform a refinement of the grid around the source location\ngrdrefpars: refined grid around the source parameters (downscalefactor and noderadius)\nradiussmoothgradsrc: radius for smoothing each individual gradient only around the source. Zero means no smoothing.\nsmoothgradkern: smooth the final gradient with a kernel of size smoothgradkern (in grid nodes). Zero means no smoothing.\nmanualGCtrigger: trigger garbage collector (GC) manually at selected points.\n\nReturns\n\nThe gradient w.r.t. velocity as a 2D or 3D array and the gradient w.r.t source location. In case only one of them is requested with whichgrad, the other one will not be returned.\nThe value of the misfit functional for the given input velocity model.\n\n\n\n\n\n","category":"function"},{"location":"publicapi/#EikonalSolvers.eikttimemisfit","page":"API","title":"EikonalSolvers.eikttimemisfit","text":"eikttimemisfit(\n    velmod::Array{Float64, N},\n    grd::EikonalSolvers.AbstractGridEik,\n    coordsrc::AbstractMatrix,\n    coordrec::AbstractVector{<:AbstractArray},\n    ttpicksobs::AbstractArray,\n    stdobs::AbstractArray;\n    extraparams\n) -> Float64\n\n\nCalculate the Gaussian misfit functional \n\n    S = dfrac12 sum_i dfracleft( mathbfu_i^rmcalc(mathbfv)-mathbfu_i^rmobs right)^2sigma_i^2  \n\nArguments\n\nvelmod: velocity model, either a 2D or 3D array.\ngrd: the struct holding the information about the grid, one of Grid2D,Grid3D,Grid2Dsphere,Grid3Dsphere\ncoordsrc: the coordinates of the source(s) (x,y), a 2-column array\ncoordrec: the coordinates of the receiver(s) (x,y) for each single source, a vector of 2-column arrays\nttpicksobs: a vector of vectors of the traveltimes at the receivers.\nstdobs: a vector of vectors standard deviations representing the error on the measured traveltimes.\nextraparams (optional): a struct containing some \"extra\" parameters, namely\nparallelkind: serial, Threads or Distributed run? (:serial, :sharedmem, :distribmem)\nrefinearoundsrc: whether to perform a refinement of the grid around the source location\ngrdrefpars: refined grid around the source parameters (downscalefactor and noderadius)\nmanualGCtrigger: trigger garbage collector (GC) manually at selected points.\n\nReturns\n\nThe value of the misfit functional (L2-norm), the same used to compute the gradient with adjoint methods.\n\n\n\n\n\n","category":"function"},{"location":"publicapi/#Extra-parameters","page":"API","title":"Extra parameters","text":"","category":"section"},{"location":"publicapi/#EikonalSolvers.ExtraParams","page":"API","title":"EikonalSolvers.ExtraParams","text":"struct ExtraParams\n\nFields\n\nrefinearoundsrc::Bool: refine grid around source?\nmanualGCtrigger::Bool: trigger GC manually at selected points\nparallelkind::Symbol: Serial, Threads or Distributed run? Either :serial, :sharedmem or :distribmem\nradiussmoothgradsrc::Int64: Radius for smoothing the gradient around the source. Zero means no smoothing.\nsmoothgradkern::Int64: Smooth the gradient with a kernel of size (in pixels). Zero means no smoothing.\ngrdrefpars::GridRefinementPars: Downscaling factor and node radius for refined grid creation\n\n\n\n\n\n","category":"type"},{"location":"publicapi/#EikonalSolvers.GridRefinementPars","page":"API","title":"EikonalSolvers.GridRefinementPars","text":"struct GridRefinementPars\n\nFields\n\ndownscalefactor::Int64: Downscaling factor for refined grid around the source\nnoderadius::Int64: Number of (coarse) grid nodes (radius) within which to refine the grid\n\n\n\n\n\n","category":"type"},{"location":"publicapi/#Ray-tracing","page":"API","title":"Ray tracing","text":"","category":"section"},{"location":"publicapi/#EikonalSolvers.tracerays","page":"API","title":"EikonalSolvers.tracerays","text":"tracerays(\n    grd::EikonalSolvers.AbstractGridEik,\n    ttime::Vector{Array{Float64}},\n    coordsrc::Matrix{Float64},\n    coordrec::Vector{Matrix{Float64}};\n    steplen\n) -> Vector{Vector{Matrix{Float64}}}\n\n\nRay tracing utility. Given a traveltime grid and source and receiver positions, trace the rays.\n\n\n\n\n\n","category":"function"},{"location":"publicapi/#HMCsampler-wrapper","page":"API","title":"HMCsampler wrapper","text":"","category":"section"},{"location":"publicapi/#EikonalSolvers.HMCtraveltimes","page":"API","title":"EikonalSolvers.HMCtraveltimes","text":"HMCtraveltimes\n\nA convenience module to facilitate the use of EikonalSolvers within the   framework of Hamiltonian Monte Carlo inversion by employing the package HMCsampler. \n\nExports\n\nEikonalProbSrcLoc\nEikonalProbVel\nEikonalProbVelAndSrcLoc\n\n\n\n\n\n","category":"module"},{"location":"publicapi/#EikonalSolvers.HMCtraveltimes.EikonalProbVel","page":"API","title":"EikonalSolvers.HMCtraveltimes.EikonalProbVel","text":"struct EikonalProbVel\n\nFields\n\ngrd::Union{Grid2DCart, Grid3DCart}\ndobs::Vector{Vector{Float64}}\nstdobs::Vector{Vector{Float64}}\ncoordsrc::Matrix{Float64}\ncoordrec::Vector{Matrix{Float64}}\nwhichgrad::Symbol\nlogVel::Bool\nextraparams::Union{Nothing, ExtraParams}\n\n\n\n\n\n","category":"type"},{"location":"publicapi/#EikonalSolvers.HMCtraveltimes.EikonalProbSrcLoc","page":"API","title":"EikonalSolvers.HMCtraveltimes.EikonalProbSrcLoc","text":"struct EikonalProbSrcLoc\n\nFields\n\ngrd::Union{Grid2DCart, Grid3DCart}\ndobs::Vector{Vector{Float64}}\nstdobs::Vector{Vector{Float64}}\ncoordrec::Vector{Matrix{Float64}}\nvelmod::Matrix{Float64}\nwhichgrad::Symbol\nextraparams::Union{Nothing, ExtraParams}\n\n\n\n\n\n","category":"type"},{"location":"publicapi/#Extensions","page":"API","title":"Extensions","text":"","category":"section"},{"location":"publicapi/#EikonalSolvers.savemodelvtk","page":"API","title":"EikonalSolvers.savemodelvtk","text":"This function requires the package WriteVTK to be loaded first in order to work.\n\n\n\n\n\n","category":"function"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\",\"publicapi.md\",\"privatestuff.md\"]\nDepth = 2","category":"page"},{"location":"#EikonalSolvers's-documentation","page":"Home","title":"EikonalSolvers's documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A library to perform seismic traveltime computations by solving the eikonal equation in two (2D) and three dimensions (3D) with the possibility of computing the gradient of a misfit function with respect to the velocity model and the source location. The coordinate system can be either regular Cartesian or spherical. The forward algorithm is based on a fast marching (FMM) method (2nd order) with a refinement of the grid around the source location. The computation of the gradient relies on the discrete adjoint method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For historical reasons, alternative solvers are available (poorly maintained), including a first order FMM method and the fast sweeping (FS) method for global updates with different kinds of local stencils. Additionally, a continuos adjoint method to calculate the gradient is also provided.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Both forward and gradient (adjoint) computations can be run in paralle using either Julia's distributed computing functions for distributed memory or threads for multicore processor. The parallelisation scheme is \"by source\", distributing calculations for different seismic sources to different processors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This code is part of a larger project G⁻¹Lab (a superset of HMCLab[ZuninoGebraadetal2023]) targeting probabilistic geophysical inverse problems. Please cite the following papers if you use this code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Andrea Zunino, Scott Keating, Andreas Fichtner (2025), A discrete adjoint method for deterministic and probabilistic eikonal-equation-based inversion of traveltime for velocity and source location, Geophysical Journal International, Volume 243, Issue 1, October 2025, ggaf283, https://doi.org/10.1093/gji/ggaf283\nAndrea Zunino, Lars Gebraad, Alessandro Ghirotto, Andreas Fichtner (2023), HMCLab: a framework for solving diverse geophysical inverse problems using the Hamiltonian Monte Carlo method, Geophysical Journal International, Volume 235, Issue 3, Pages 2979–2991, https://doi.org/10.1093/gji/ggad403","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package simple enter into the package manager mode in Julia by typing \"]\" at the REPL prompt and then use add, i.e.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.11) pkg> registry add https://github.com/Ginvlab/GinvLabRegistry\n(v1.11) pkg> add EikonalSolvers","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package will be automatically downloaded from the web and installed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, use the path where the directory of the package is located, be it remote (GitHub)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.11) pkg> add https://github.com/GinvLab/EikonalSolvers.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"or local","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.11) pkg> add /<path>/<to>/EikonalSolvers.jl","category":"page"},{"location":"#Theoretical-background","page":"Home","title":"Theoretical background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The eikonal equation in 3D is given by:","category":"page"},{"location":"","page":"Home","title":"Home","text":" nabla tau ^2 = left( dfracpartial taupartial x right)^2 +\nleft( dfracpartial taupartial y right)^2  +\nleft( dfracpartial taupartial z right)^2 =\ndfrac1v^2(xyz)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where tau is the travel time, xyz the spatial coordinates and v the velocity.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the numerical solution to the eikonal equation, there are two major components, the global scheme, which defines the strategy to update to the traveltime on the grid, i.e., the fast marching method and the local scheme, providing the finite difference stencils.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The gradient computations are based on the adjoint state method (see below). For details please refer to the paper [Zuninoetal2025].","category":"page"},{"location":"#Numerical-implementation","page":"Home","title":"Numerical implementation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The solver for the eikonal equation ([ZuninoGebraadetal2023]) is a second-order fast marching method (FMM) ([Sethian1996], [SethianPopovici1999]) using traditional stencils (e.g., [RawlinsonSambridge2004]), with an additional refinement of the grid around the source.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Regarding the gradient of the misfit function with respect to velocity, the misfit function (without considering the prior) is defined as","category":"page"},{"location":"","page":"Home","title":"Home","text":"S = dfrac12 sum_i dfracleft( mathbftau_i^rmcalc(mathbfv)-mathbftau_i^rmobs right)^2sigma_i^2  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The gradient of the above functional with respect to the velocity model dfracd Sd mathbfv can be calculated efficiently using the adjoint state method (e.g., [LeungQian2006], [TreisterHaber2016]]). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this package we employ the discrete adjoint state method to compute both gradients with respect to velocity and source location [Zuninoetal2025], which takes into account the non-linearity of the forward problem - i.e., no linearisation of the forward model and no rays are employed. The computational cost is almost independent of the number of receivers and, because of the discretization, the result is a \"diffuse\" sensitivity around the theoretical rays (see an example in the following). ","category":"page"},{"location":"#Exported-functions-/-API","page":"Home","title":"Exported functions / API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following sets of functions are exported by EikonalSolvers. Units are arbitrary but must be consistent.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The geometry and size of the grid is defined via structures for Cartesian coordinates (rectilinear grids) or spherical/polar coordinates (curvilinear grids):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Grid2DCart, a struct describing the geometry and size of a 2D Cartesian grid;\nGrid3DCart, a struct describing the geometry and size of a 3D  Cartesian grid;\nGrid2DSphere, a struct describing the geometry and size of a 2D spherical grid;\nGrid3DSphere, a struct describing the geometry and size of a 3D spherical grid;","category":"page"},{"location":"","page":"Home","title":"Home","text":"The traveltime computations are performed using the following functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"eiktraveltime, which computes the traveltimes in a 2D or 3D model; ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The gradient computations (using a 2D or 3D grid), instead, by","category":"page"},{"location":"","page":"Home","title":"Home","text":"eikgradient, which computes the gradient of the misfit function with respect to velocity and/or source location.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, the misfit functional calculation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"eikttimemisfit, computes the value (scalar) of the misfit functional for given observed traveltimes and velocity model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Moreover, a convenience module HMCTraveltimes (see EikonalSolvers.HMCtraveltimes) is provided to facilitate the use of EikonalSolvers within the framework of Hamiltonian Monte Carlo inversion (see e.g. [ZuninoMosegaard2018]) by employing the package HMCsampler. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"ExtraParams also may play an important role in certain user cases.","category":"page"},{"location":"#Parallelisation","page":"Home","title":"Parallelisation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Both forward and gradient computations are parallelised using Julia's distributed computating functions. The parallelisation is \"by source\", meaning that traveltimes (or gradients) for different sources are computed in parallel. Therefore if there are N input sources and P processors, each processor will perform computations for about N over P sources. The number of processors corresponds to the number of \"threads\" or \"workers\" (Threads.nthreads() or nworkers()) available to Julia when the computations are run. To enable parallel calculations the field parallelkind in the ExtraParams struct must be set either to :sharedmem or :distribmem\" and passed to the forward or inverse routines. Default is :serial.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get more than one thread for shared memory computing, Julia can either be started with julia -t <N> where N is the desired number of threads. To get more than one processor for distributed computing, instead, Julia can either be started with julia -p <N> where N is the desired number of processors or using addprocs(<N>) before loading the module. ","category":"page"},{"location":"#Example-of-forward-calculations","page":"Home","title":"Example of forward calculations","text":"","category":"section"},{"location":"#Cartesian-coordinates","page":"Home","title":"Cartesian coordinates","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As an illustration in the following it is shown how to calculate traveltimes at receivers in 2D in Cartesian coordinates.  Let's start with a complete example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using EikonalSolvers\ngrd = Grid2DCart(hgrid=0.5,cooinit=(0.0,0.0),grsize=(300,220))  # create the Grid2D struct\nnsrc = 4\nnrec = 10\ncoordsrc = [grd.hgrid.*LinRange(10,290,nsrc)  grd.hgrid.*200.0.*ones(nsrc)] # coordinates of the sources (4 sources)\ncoordrec = [ [grd.hgrid.*LinRange(8,294,nrec) grd.hgrid.*20.0.*ones(nrec)] for i=1:nsrc] # coordinates of the receivers (10 receivers)\nvelmod = 2.5 .* ones(grd.grsize...)   # velocity model\n# increasing velocity with depth...\nfor i=1:grd.grsize[2] \n  velmod[:,i] = 0.034 * i .+ velmod[:,i] \nend\n\n# run the traveltime computation \nttimepicks = eiktraveltime(velmod,grd,coordsrc,coordrec)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output will be a vector of vectors with 4 elements (number of sources) each of which being a 10-element array (number of receivers):","category":"page"},{"location":"","page":"Home","title":"Home","text":"ttimepicks","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now let's analyse more in details the various components.  First of we have to import the module and define the parameters of the grid using the struct Grid2D:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using EikonalSolvers\n# hgrid: grid spacing\n# cooinit: grid origin coordinates\n# grsize: grid size\ngrd = Grid2DCart(hgrid=0.5,cooinit=(0.0,0.0),grsize=(300,220)) # create the Grid2D struct","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then define the coordinates of the sources, a two-column array (since we are in 2D) representing the $x$ and $y$ coordinates","category":"page"},{"location":"","page":"Home","title":"Home","text":"nsrc = 4\ncoordsrc = [grd.hgrid.*LinRange(10,290,4)   grd.hgrid.*200.0.*ones(4)] ","category":"page"},{"location":"","page":"Home","title":"Home","text":"and the receivers, a \"vector of arrays\", i.e., a vector where each element (one element per each source) is a two-column array (since we are in 2D) representing the $x$ and $y$ coordinates","category":"page"},{"location":"","page":"Home","title":"Home","text":"nrec = 10\ncoordrec = [ [grd.hgrid.*LinRange(8,294,nrec) grd.hgrid.*20.0.*ones(nrec)] for i=1:nsrc] # coordinates of the receivers (10 receivers)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The velocity model is defined as a 2D array with size (grd.grsize)","category":"page"},{"location":"","page":"Home","title":"Home","text":"velmod = 2.5 .* ones(grd.grsize...) \n# increasing velocity with depth...\nfor i=1:grd.grsize[2]\n  velmod[:,i] = 0.034 * i .+ velmod[:,i] \nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, the traveltime at receivers is computed","category":"page"},{"location":"","page":"Home","title":"Home","text":"ttimepicks = eiktraveltime(velmod,grd,coordsrc,coordrec)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now the traveltimes can be plotted, e.g., using Makie","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie\n\nfig = Figure(size=(800,300))\n\nax1 = Axis(fig[1,1][1,1],title=\"Velocity model, sources and receivers\",xlabel=\"x [Km]\",ylabel=\"y [Km]\")\nhm = heatmap!(ax1,grd.x,grd.y,velmod,colormap=:rainbow1) \nColorbar(fig[1,1][1,2],hm,label=\"Velocity [km/s]\")\nfor cr in coordrec\n\tscatter!(ax1,cr[:,1],cr[:,2],marker=:dtriangle,color=:black)\nend\nscatter!(ax1,coordsrc[:,1],coordsrc[:,2],marker=:circle,color=:black)\nax1.yreversed=true\n\nax2 = Axis(fig[1,2],title=\"Traveltimes\",xlabel=\"Receiver #\",ylabel=\"Traveltime [s]\")\nfor (i,tt) in enumerate(ttimepicks)\n\tscatterlines!(ax2,1:length(tt),tt[:],label=\"tt src #$i\")\nend\naxislegend(ax2)\n\nsave(\"images/velmod-ttpicks.png\",fig) # hide\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: velmodttpicks)","category":"page"},{"location":"","page":"Home","title":"Home","text":"@show ttimepicks","category":"page"},{"location":"","page":"Home","title":"Home","text":"To additionally return the traveltime everywhere on the grid do","category":"page"},{"location":"","page":"Home","title":"Home","text":"ttimepicks,ttimegrid = eiktraveltime(velmod,grd,coordsrc,coordrec,returntt=true)\n@show size(ttimegrid)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"The traveltime across all grid can then be visualized","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie\n\nfig = Figure(size=(800,300))\n\ns = 1\nax1 = Axis(fig[1,1][1,1],title=\"Traveltime for source #$s\",xlabel=\"x [Km]\",ylabel=\"y [Km]\")\nhm = heatmap!(ax1,grd.x,grd.y,ttimegrid[s],colormap=:rainbow1) \nColorbar(fig[1,1][1,2],hm,label=\"Traveltime [s]\")\ncontour!(ax1,grd.x,grd.y,ttimegrid[s],color=:black)\nfor cr in coordrec\n\tscatter!(ax1,cr[:,1],cr[:,2],marker=:dtriangle,color=:black)\nend\nscatter!(ax1,coordsrc[s,1],coordsrc[s,2],marker=:circle,color=:black)\nax1.yreversed=true\n\ns = 3\nax2 = Axis(fig[1,2][1,1],title=\"Traveltime for source #$s\",xlabel=\"x [Km]\",ylabel=\"y [Km]\")\nhm = heatmap!(ax2,grd.x,grd.y,ttimegrid[s],colormap=:rainbow1) \nColorbar(fig[1,2][1,2],hm,label=\"Traveltime [s]\")\ncontour!(ax2,grd.x,grd.y,ttimegrid[s],color=:black)\nfor cr in coordrec\n\tscatter!(ax2,cr[:,1],cr[:,2],marker=:dtriangle,color=:black)\nend\nscatter!(ax2,coordsrc[s,1],coordsrc[s,2],marker=:circle,color=:black)\nax2.yreversed=true\n\nsave(\"images/ttime-arrays.png\",fig) # hide\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: ttarrays) The resulting traveltime array on the grid is returned as a three-dimensional array, containing a set of two-dimensional arrays, one for each source.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@show size(ttimegrid)","category":"page"},{"location":"#Spherical-coordinates","page":"Home","title":"Spherical coordinates","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here we show an example of traveltime calculation in spherical coordinates in 2D. The grid is defined in terms of the radius r and the angle θ, representing the co-latitude. In 3D there is the additional angle φ, representing the longitude. Remark: for spherical coordinates some Greek symbols are used. You can render them in Julia as following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Symbol How to render\nΔ \\Delta^TAB\nθ \\theta^TAB\nφ \\varphi^TAB","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function for traveltimes in spherical coordinates, analogously to the Cartesian case, is traveltime2Dsphere(). The grid setup and forward computations are carried out as shown in the following script.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using EikonalSolvers\ngrd = Grid2DSphere(Δr=2.0,Δθ=0.2,grsize=(40,70),cooinit=(500.0,10.0)) # create the Grid2DSphere struct \ncoordsrc = [grd.cooinit[1].+grd.Δr*3  grd.cooinit[2].+grd.Δθ*(grd.grsize[2]-5)] # coordinates of the sources (1 source) \ncoordrec = [[grd.cooinit[1].+grd.Δr*(grd.grsize[1]-3) grd.cooinit[2].+grd.Δθ*3] ] # coordinates of the receivers (1 receiver), vector of arrays \nvelmod = 2.5 .* ones(grd.grsize...)                       # velocity model \n\n# run the traveltime computation \nttimepicks = eiktraveltime(velmod,grd,coordsrc,coordrec) \nnothing # hide ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following picture shows an example of computed traveltime and gradient in spherical coordinates in 2D.  (Image: sph2dttgrad) ","category":"page"},{"location":"#Example-of-gradient-w.r.t-velocity-calculation","page":"Home","title":"Example of gradient w.r.t velocity calculation","text":"","category":"section"},{"location":"#Cartesian-coordinates-2","page":"Home","title":"Cartesian coordinates","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here a synthetic example of 2D gradient computations in Cartesian coordinates is illustrated. In reality, traveltime data are \"measured\" from recorded seismograms, however, here we first create some synthetic \"observed\" traveltimes using a synthetic velocity model. First the grid and velocity model are set up, then forward calculations are performed, as in the section above Example of forward calculations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using EikonalSolvers\nhgrid=0.5\ngrd = Grid2DCart(hgrid=hgrid,cooinit=(0.0,0.0),grsize=(300,220))         # create the Grid2D struct\nnsrc = 4\nnrec = 10\ncoordsrc = [0.95*hgrid.*LinRange(12,290,nsrc)   hgrid.*207.0.*ones(nsrc)] # coordinates of the sources (4 sources)\ncoordrec = [[hgrid.*LinRange(8.0,290.0,nrec)  hgrid.*20.0.*ones(nrec)] for i=1:nsrc] # coordinates of the receivers (10 receivers)\nvelmod = 2.5 .* ones(grd.grsize...)                                # velocity model\n# increasing velocity with depth\nfor i=1:grd.grsize[2]\n  velmod[:,i] = 0.034 * i .+ velmod[:,i]\nend\n\n# run the traveltime computation \nttpicks = eiktraveltime(velmod,grd,coordsrc,coordrec)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then the \"observed\" traveltime data are created by adding some Gaussian noise to the traveltimes computed above to simulate real measurements.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# standard deviation of error on observed data\nstdobs = [0.15.*ones(size(ttpicks[1])) for i=1:nsrc]\n# generate a \"noise\" array to simulate real data\nnoise = [stdobs[i].^2 .* randn(size(stdobs[i])) for i=1:nsrc]\n# add the noise to the synthetic traveltime data\ndobs = ttpicks .+ noise \nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we can finally compute the gradient of the misfit functional (see above) at a given point, i.e., the gradient is computed at a given velocity model: dfracd Sd mathbfv Big_mathbfv_0.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# create a guess/\"current\" model\nvel0 = 2.3 .* ones(grd.grsize...)\n# increasing velocity with depth...\nfor i=1:grd.grsize[2]\n   vel0[:,i] = 0.015 * i .+ vel0[:,i]\nend\n    \n# calculate the gradient of the misfit function\ngradvel,misf = eikgradient(vel0,grd,coordsrc,coordrec,dobs,stdobs,:gradvel)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, plot the rsults ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie\n\nfig = Figure(size=(800,300))\n\nax1 = Axis(fig[1,1][1,1],title=\"Reference velocity model\",xlabel=\"x [Km]\",ylabel=\"y [Km]\")\nhm = heatmap!(ax1,grd.x,grd.y,vel0,colormap=:rainbow1) \nColorbar(fig[1,1][1,2],hm,label=\"Velocity [km/s]\")\nfor cr in coordrec\n\tscatter!(ax1,cr[:,1],cr[:,2],marker=:dtriangle,color=:black)\nend\nscatter!(ax1,coordsrc[:,1],coordsrc[:,2],marker=:circle,color=:black)\nax1.yreversed=true\n\nax2 = Axis(fig[1,2][1,1],title=\"Gradient w.r.t. velocity\",xlabel=\"x [Km]\",ylabel=\"y [Km]\")\nvmax = maximum(abs.(gradvel))\nhm = heatmap!(ax2,grd.x,grd.y,gradvel,colormap=:seismic,colorrange=(-vmax,vmax)) \nColorbar(fig[1,2][1,2],hm,label=\"Gradient\")\nfor cr in coordrec\n\tscatter!(ax2,cr[:,1],cr[:,2],marker=:dtriangle,color=:black)\nend\nscatter!(ax2,coordsrc[:,1],coordsrc[:,2],marker=:circle,color=:black)\nax2.yreversed=true\n\nsave(\"images/grad-vel.png\",fig) # hide\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: ttarrays) The calculated gradient is an array with the same shape than the velocity model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@show size(gradvel)","category":"page"},{"location":"#Spherical-coordinates-2","page":"Home","title":"Spherical coordinates","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here a synthetic example of 2D gradient computations in spherical coordinates is shown.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using EikonalSolvers\ngrd = Grid2DSphere(Δr=2.0,Δθ=0.2,grsize=(40,70),cooinit=(500.0,10.0)) # create the Grid2DSphere struct\ncoordsrc = [grd.cooinit[1].+grd.Δr*3  grd.cooinit[2].+grd.Δθ*(grd.grsize[2]-5)] # coordinates of the sources (1 source)\nnsrc = size(coordsrc,1)\ncoordrec = [[grd.cooinit[1].+grd.Δr*(grd.grsize[1]-3) grd.cooinit[2].+grd.Δθ*3] for i=1:nsrc] # coordinates of the receivers (1 receiver)\n\n# velocity model\nvelmod = 2.5 .* ones(grd.grsize...)\n# run the traveltime computation\nttpicks = eiktraveltime(velmod,grd,coordsrc,coordrec) \n\n# standard deviation of error on observed data \nstdobs = [0.15.*ones(size(ttpicks[1])) for i=1:nsrc] \n# generate a \"noise\" array to simulate real data \nnoise = [stdobs[i].^2 .* randn(size(stdobs[i])) for i=1:nsrc] \n# add the noise to the synthetic traveltime data \ndobs = ttpicks .+ noise \n\n# create a guess/\"current\" model  \nvel0 = 3.0 .* ones(grd.grsize...) \n\n# calculate the gradient of the misfit function \ngrad,misf = eikgradient(vel0,grd,coordsrc,coordrec,dobs,stdobs,:gradvel) \nnothing # hide ","category":"page"},{"location":"","page":"Home","title":"Home","text":"An example of a (thresholded) sensitivity kernel and contouring of traveltimes in 3D, using spherical coordinates, is depicted in the following plot:   (Image: grad3D) ","category":"page"},{"location":"#Example-of-gradient-w.r.t-source-location-calculation","page":"Home","title":"Example of gradient w.r.t source location calculation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here a synthetic example of 2D gradient computation w.r.t. source location in Cartesian coordinates is illustrated. In reality, traveltime data are \"measured\" from recorded seismograms, however, here we first create some synthetic \"observed\" traveltimes using a given velocity model. First the grid and velocity model are set up, then forward calculations are performed, as in the section above Example of forward calculations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using EikonalSolvers\nhgrid=0.5\ngrd = Grid2DCart(hgrid=hgrid,cooinit=(0.0,0.0),grsize=(300,220))         # create the Grid2D struct\nnsrc = 4\nnrec = 10\ncoordsrc = [0.95*hgrid.*LinRange(12,290,nsrc)   hgrid.*207.0.*ones(nsrc)] # coordinates of the sources (4 sources)\ncoordrec = [[hgrid.*LinRange(8.0,290.0,nrec)  hgrid.*20.0.*ones(nrec)] for i=1:nsrc] # coordinates of the receivers (10 receivers)\nvelmod = 2.5 .* ones(grd.grsize...)                                # velocity model\n# increasing velocity with depth\nfor i=1:grd.grsize[2]\n  velmod[:,i] = 0.034 * i .+ velmod[:,i]\nend\n\n# run the traveltime computation \nttpicks = eiktraveltime(velmod,grd,coordsrc,coordrec)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then the \"observed\" traveltime data are created by adding some Gaussian noise to the traveltimes computed above to simulate real measurements.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# standard deviation of error on observed data\nstdobs = [0.15.*ones(size(ttpicks[1])) for i=1:nsrc]\n# generate a \"noise\" array to simulate real data\nnoise = [stdobs[i].^2 .* randn(size(stdobs[i])) for i=1:nsrc]\n# add the noise to the synthetic traveltime data\ndobs = ttpicks .+ noise \nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now the gradient w.r.t. source location, dfracd Sd mathbfx^rm src, can be computed as follows","category":"page"},{"location":"","page":"Home","title":"Home","text":"# calculate the gradient of the misfit function w.r.t. source location\n#   notice the last argument :gradsrcloc\ngradsrcloc,misf = eikgradient(velmod,grd,coordsrc,coordrec,dobs,stdobs,:gradsrcloc)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"The gradient is returned as an array where each row contains the partial derivatives for each source:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# now print the partial derivatives\n@show(gradsrcloc)","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[ZuninoGebraadetal2023]: Zunino A., Gebraad, L., Ghirotto, A. and Fichtner, A., (2023). HMCLab a framework for solving diverse geophysical inverse problems using the Hamiltonian Monte Carlo algorithm, Geophysical Journal International, Volume 235, Issue 3, December 2023, Pages 2979–2991, https://doi.org/10.1093/gji/ggad403.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Zuninoetal2025]: Andrea Zunino, Scott Keating, Andreas Fichtner (2025), **A discrete adjoint method for deterministic and probabilistic eikonal-equation-based inversion of traveltime for velocity and source location, arXiv preprint arXiv:2501.13532.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[LeungQian2006]: Leung, S. and Qian, J. (2006). An adjoint state method for three-dimensional transmission traveltime tomography using first-arrivals. Communications in Mathematical Sciences, 4(1), 249-266.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[TreisterHaber2016]: Treister, Eran & Haber, Eldad. (2016). A fast marching algorithm for the factored eikonal equation. Journal of Computational Physics. 324. 210–225. 10.1016/j.jcp.2016.08.012. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"[RawlinsonSambridge2004]: Rawlinson, N. and Sambridge, M. (2004). Wave front evolution in strongly heterogeneous layered media using the fast marching method. Geophys. J. Int., 156(3), 631-647.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Sethian1996]: Sethian A. J. (1996). A fast marching level set method for monotonically advancing fronts. Proceedings of the National Academy of Sciences Feb 1996, 93 (4) 1591-1595. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"[SethianPopovici1999]: Sethian A. J. and Popovici A. (1999). Three dimensional traveltimes computation using the Fast Marching Method. Geophysics. 64. 516-523. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"[ZuninoMosegaard2018]: Zunino A., Mosegaard K. (2018), Integrating Gradient Information with Probabilistic Traveltime Tomography Using the Hamiltonian Monte Carlo Algorithm, 80th EAGE Conference & Exhibition, Copenhagen.","category":"page"}]
}
