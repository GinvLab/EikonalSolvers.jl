<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · EikonalSolvers.jl</title><meta name="title" content="Home · EikonalSolvers.jl"/><meta property="og:title" content="Home · EikonalSolvers.jl"/><meta property="twitter:title" content="Home · EikonalSolvers.jl"/><meta name="description" content="Documentation for EikonalSolvers.jl."/><meta property="og:description" content="Documentation for EikonalSolvers.jl."/><meta property="twitter:description" content="Documentation for EikonalSolvers.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>EikonalSolvers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#EikonalSolvers&#39;s-documentation"><span>EikonalSolvers&#39;s documentation</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Theoretical-background"><span>Theoretical background</span></a></li><li><a class="tocitem" href="#Numerical-implementation"><span>Numerical implementation</span></a></li><li><a class="tocitem" href="#Exported-functions-/-API"><span>Exported functions / API</span></a></li><li><a class="tocitem" href="#Parallelisation"><span>Parallelisation</span></a></li><li><a class="tocitem" href="#Example-of-forward-calculations"><span>Example of forward calculations</span></a></li><li><a class="tocitem" href="#Example-of-gradient-w.r.t-velocity-calculation"><span>Example of gradient w.r.t velocity calculation</span></a></li><li><a class="tocitem" href="#Example-of-gradient-w.r.t-source-location-calculation"><span>Example of gradient w.r.t source location calculation</span></a></li><li class="toplevel"><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="publicapi/">API</a></li><li><a class="tocitem" href="privatestuff/">Private stuff</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GinvLab/EikonalSolvers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GinvLab/EikonalSolvers.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h1><ul><li><a href="#Contents">Contents</a></li><li><a href="#EikonalSolvers&#39;s-documentation">EikonalSolvers&#39;s documentation</a></li><li class="no-marker"><ul><li><a href="#Installation">Installation</a></li><li><a href="#Theoretical-background">Theoretical background</a></li><li><a href="#Numerical-implementation">Numerical implementation</a></li><li><a href="#Exported-functions-/-API">Exported functions / API</a></li><li><a href="#Parallelisation">Parallelisation</a></li><li><a href="#Example-of-forward-calculations">Example of forward calculations</a></li><li><a href="#Example-of-gradient-w.r.t-velocity-calculation">Example of gradient w.r.t velocity calculation</a></li><li><a href="#Example-of-gradient-w.r.t-source-location-calculation">Example of gradient w.r.t source location calculation</a></li></ul></li><li><a href="#References">References</a></li><li><a href="publicapi/#API,-exported-functions">API, exported functions</a></li><li class="no-marker"><ul><li><a href="publicapi/#Cartesian/spherical-grids-structures">Cartesian/spherical grids structures</a></li><li><a href="publicapi/#Forward,-gradient-and-misfit-calculation-functions">Forward, gradient and misfit calculation functions</a></li><li><a href="publicapi/#Extra-parameters">Extra parameters</a></li><li><a href="publicapi/#Ray-tracing">Ray tracing</a></li><li><a href="publicapi/#HMCsampler-wrapper">HMCsampler wrapper</a></li><li><a href="publicapi/#Extensions">Extensions</a></li></ul></li><li><a href="privatestuff/#Don&#39;t-use-these...">Don&#39;t use these...</a></li><li class="no-marker"><ul><li><a href="privatestuff/#EikonalSolvers">EikonalSolvers</a></li><li><a href="privatestuff/#Binary-heap(s)">Binary heap(s)</a></li></ul></li></ul><h1 id="EikonalSolvers&#39;s-documentation"><a class="docs-heading-anchor" href="#EikonalSolvers&#39;s-documentation">EikonalSolvers&#39;s documentation</a><a id="EikonalSolvers&#39;s-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#EikonalSolvers&#39;s-documentation" title="Permalink"></a></h1><p>A library to perform seismic traveltime computations by solving the eikonal equation in two (2D) and three dimensions (3D) with the possibility of computing the gradient of a misfit function with respect to the velocity model and the source location. The coordinate system can be either regular Cartesian or spherical. The forward algorithm is based on a fast marching (FMM) method (2nd order) with a refinement of the grid around the source location. The computation of the gradient relies on the discrete adjoint method.</p><p>For historical reasons, alternative solvers are available (poorly maintained), including a first order FMM method and the fast sweeping (FS) method for global updates with different kinds of local stencils. Additionally, a continuos adjoint method to calculate the gradient is also provided.</p><p>Both forward and gradient (adjoint) computations can be run in paralle using either Julia&#39;s distributed computing functions for distributed memory or threads for multicore processor. The parallelisation scheme is &quot;by source&quot;, distributing calculations for different seismic sources to different processors.</p><p>This code is part of a larger project <code>G⁻¹Lab</code> (a superset of HMCLab<sup class="footnote-reference"><a id="citeref-ZuninoGebraadetal2023" href="#footnote-ZuninoGebraadetal2023">[ZuninoGebraadetal2023]</a></sup>) targeting probabilistic geophysical inverse problems. Please cite the following papers if you use this code:</p><ul><li><p>Andrea Zunino, Scott Keating, Andreas Fichtner (2025), <strong>A discrete adjoint method for deterministic and probabilistic eikonal-equation-based inversion of traveltime for velocity and source location</strong>, Geophysical Journal International, Volume 243, Issue 1, October 2025, ggaf283, <a href="https://doi.org/10.1093/gji/ggaf283">https://doi.org/10.1093/gji/ggaf283</a></p></li><li><p>Andrea Zunino, Lars Gebraad, Alessandro Ghirotto, Andreas Fichtner (2023), <strong>HMCLab: a framework for solving diverse geophysical inverse problems using the Hamiltonian Monte Carlo method</strong>, Geophysical Journal International, Volume 235, Issue 3, Pages 2979–2991, <a href="https://doi.org/10.1093/gji/ggad403">https://doi.org/10.1093/gji/ggad403</a></p></li></ul><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>To install the package simple enter into the package manager mode in Julia by typing &quot;<code>]</code>&quot; at the REPL prompt and then use <code>add</code>, i.e.,</p><pre><code class="nohighlight hljs">(v1.11) pkg&gt; registry add https://github.com/Ginvlab/GinvLabRegistry
(v1.11) pkg&gt; add EikonalSolvers</code></pre><p>The package will be automatically downloaded from the web and installed.</p><p>Alternatively, use the path where the directory of the package is located, be it remote (GitHub)</p><pre><code class="nohighlight hljs">(v1.11) pkg&gt; add https://github.com/GinvLab/EikonalSolvers.jl</code></pre><p>or local</p><pre><code class="nohighlight hljs">(v1.11) pkg&gt; add /&lt;path&gt;/&lt;to&gt;/EikonalSolvers.jl</code></pre><h2 id="Theoretical-background"><a class="docs-heading-anchor" href="#Theoretical-background">Theoretical background</a><a id="Theoretical-background-1"></a><a class="docs-heading-anchor-permalink" href="#Theoretical-background" title="Permalink"></a></h2><p>The eikonal equation in 3D is given by:</p><p class="math-container">\[| \nabla \tau |^2 = \left( \dfrac{\partial \tau}{\partial x} \right)^2 +
\left( \dfrac{\partial \tau}{\partial y} \right)^2  +
\left( \dfrac{\partial \tau}{\partial z} \right)^2 =
\dfrac{1}{v^2(x,y,z)}\]</p><p>where <span>$\tau$</span> is the travel time, <span>$x,y,z$</span> the spatial coordinates and <span>$v$</span> the velocity.</p><p>In the numerical solution to the eikonal equation, there are two major components, the global scheme, which defines the strategy to update to the traveltime on the grid, i.e., the fast marching method and the local scheme, providing the finite difference stencils.</p><p>The gradient computations are based on the adjoint state method (see below). For details please refer to the paper <sup class="footnote-reference"><a id="citeref-Zuninoetal2025" href="#footnote-Zuninoetal2025">[Zuninoetal2025]</a></sup>.</p><h2 id="Numerical-implementation"><a class="docs-heading-anchor" href="#Numerical-implementation">Numerical implementation</a><a id="Numerical-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-implementation" title="Permalink"></a></h2><p>The solver for the eikonal equation (<sup class="footnote-reference"><a id="citeref-ZuninoGebraadetal2023" href="#footnote-ZuninoGebraadetal2023">[ZuninoGebraadetal2023]</a></sup>) is a second-order fast marching method (FMM) (<sup class="footnote-reference"><a id="citeref-Sethian1996" href="#footnote-Sethian1996">[Sethian1996]</a></sup>, <sup class="footnote-reference"><a id="citeref-SethianPopovici1999" href="#footnote-SethianPopovici1999">[SethianPopovici1999]</a></sup>) using traditional stencils (e.g., <sup class="footnote-reference"><a id="citeref-RawlinsonSambridge2004" href="#footnote-RawlinsonSambridge2004">[RawlinsonSambridge2004]</a></sup>), with an additional refinement of the grid around the source.</p><p>Regarding the gradient of the misfit function with respect to velocity, the misfit function (without considering the prior) is defined as</p><p class="math-container">\[S = \dfrac{1}{2} \sum_i \dfrac{\left( \mathbf{\tau}_i^{\rm{calc}}(\mathbf{v})-\mathbf{\tau}_i^{\rm{obs}} \right)^2}{\sigma_i^2} \, .\]</p><p>The gradient of the above functional with respect to the velocity model <span>$\dfrac{d S}{d \mathbf{v}}$</span> can be calculated efficiently using the <em>adjoint</em> state method (e.g., <sup class="footnote-reference"><a id="citeref-LeungQian2006" href="#footnote-LeungQian2006">[LeungQian2006]</a></sup>, <sup class="footnote-reference"><a id="citeref-TreisterHaber2016" href="#footnote-TreisterHaber2016">[TreisterHaber2016]</a></sup>]). </p><p>In this package we employ the <strong>discrete adjoint state method</strong> to compute both gradients with respect to velocity and source location <sup class="footnote-reference"><a id="citeref-Zuninoetal2025" href="#footnote-Zuninoetal2025">[Zuninoetal2025]</a></sup>, which takes into account the non-linearity of the forward problem - i.e., <em>no</em> linearisation of the forward model and <em>no</em> rays are employed. The computational cost is almost independent of the number of receivers and, because of the discretization, the result is a &quot;diffuse&quot; sensitivity around the theoretical rays (see an example in the following). </p><h2 id="Exported-functions-/-API"><a class="docs-heading-anchor" href="#Exported-functions-/-API">Exported functions / API</a><a id="Exported-functions-/-API-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions-/-API" title="Permalink"></a></h2><p>The following sets of functions are exported by <code>EikonalSolvers</code>. Units are arbitrary but must be <em>consistent</em>.</p><p>The geometry and size of the grid is defined via structures for Cartesian coordinates (rectilinear grids) or spherical/polar coordinates (curvilinear grids):</p><ul><li><a href="publicapi/#EikonalSolvers.Grid2DCart"><code>Grid2DCart</code></a>, a <code>struct</code> describing the geometry and size of a 2D Cartesian grid;</li><li><a href="publicapi/#EikonalSolvers.Grid3DCart"><code>Grid3DCart</code></a>, a <code>struct</code> describing the geometry and size of a 3D  Cartesian grid;</li><li><a href="publicapi/#EikonalSolvers.Grid2DSphere"><code>Grid2DSphere</code></a>, a <code>struct</code> describing the geometry and size of a 2D spherical grid;</li><li><a href="publicapi/#EikonalSolvers.Grid3DSphere"><code>Grid3DSphere</code></a>, a <code>struct</code> describing the geometry and size of a 3D spherical grid;</li></ul><p>The traveltime computations are performed using the following functions:</p><ul><li><a href="publicapi/#EikonalSolvers.eiktraveltime"><code>eiktraveltime</code></a>, which computes the traveltimes in a 2D or 3D model; </li></ul><p>The gradient computations (using a 2D or 3D grid), instead, by</p><ul><li><a href="publicapi/#EikonalSolvers.eikgradient"><code>eikgradient</code></a>, which computes the gradient of the misfit function with respect to velocity and/or source location.</li></ul><p>Finally, the misfit functional calculation:</p><ul><li><a href="publicapi/#EikonalSolvers.eikttimemisfit"><code>eikttimemisfit</code></a>, computes the value (scalar) of the misfit functional for given observed traveltimes and velocity model.</li></ul><p>Moreover, a convenience module <code>HMCTraveltimes</code> (see <a href="publicapi/#EikonalSolvers.HMCtraveltimes"><code>EikonalSolvers.HMCtraveltimes</code></a>) is provided to facilitate the use of <code>EikonalSolvers</code> within the framework of Hamiltonian Monte Carlo inversion (see e.g. <sup class="footnote-reference"><a id="citeref-ZuninoMosegaard2018" href="#footnote-ZuninoMosegaard2018">[ZuninoMosegaard2018]</a></sup>) by employing the package <code>HMCsampler</code>. </p><p><a href="publicapi/#EikonalSolvers.ExtraParams"><code>ExtraParams</code></a> also may play an important role in certain user cases.</p><h2 id="Parallelisation"><a class="docs-heading-anchor" href="#Parallelisation">Parallelisation</a><a id="Parallelisation-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelisation" title="Permalink"></a></h2><p>Both forward and gradient computations are parallelised using Julia&#39;s distributed computating functions. The parallelisation is &quot;by source&quot;, meaning that traveltimes (or gradients) for different sources are computed in parallel. Therefore if there are <span>$N$</span> input sources and <span>$P$</span> processors, each processor will perform computations for about <span>$N \over P$</span> sources. The number of processors corresponds to the number of &quot;threads&quot; or &quot;workers&quot; (<code>Threads.nthreads()</code> or <code>nworkers()</code>) available to Julia when the computations are run. To enable parallel calculations the field <code>parallelkind</code> in the <a href="publicapi/#EikonalSolvers.ExtraParams"><code>ExtraParams</code></a> <code>struct</code> must be set either to <code>:sharedmem</code> or <code>:distribmem&quot;</code> and passed to the forward or inverse routines. Default is <code>:serial</code>.</p><p>To get more than one thread for shared memory computing, Julia can either be started with <code>julia -t &lt;N&gt;</code> where <code>N</code> is the desired number of threads. To get more than one processor for distributed computing, instead, Julia can either be started with <code>julia -p &lt;N&gt;</code> where <code>N</code> is the desired number of processors or using <code>addprocs(&lt;N&gt;)</code> <em>before</em> loading the module. </p><h2 id="Example-of-forward-calculations"><a class="docs-heading-anchor" href="#Example-of-forward-calculations">Example of forward calculations</a><a id="Example-of-forward-calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-forward-calculations" title="Permalink"></a></h2><h3 id="Cartesian-coordinates"><a class="docs-heading-anchor" href="#Cartesian-coordinates">Cartesian coordinates</a><a id="Cartesian-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Cartesian-coordinates" title="Permalink"></a></h3><p>As an illustration in the following it is shown how to calculate traveltimes at receivers in 2D in Cartesian coordinates.  Let&#39;s start with a complete example:</p><pre><code class="language-julia hljs">using EikonalSolvers
grd = Grid2DCart(hgrid=0.5,cooinit=(0.0,0.0),grsize=(300,220))  # create the Grid2D struct
nsrc = 4
nrec = 10
coordsrc = [grd.hgrid.*LinRange(10,290,nsrc)  grd.hgrid.*200.0.*ones(nsrc)] # coordinates of the sources (4 sources)
coordrec = [ [grd.hgrid.*LinRange(8,294,nrec) grd.hgrid.*20.0.*ones(nrec)] for i=1:nsrc] # coordinates of the receivers (10 receivers)
velmod = 2.5 .* ones(grd.grsize...)   # velocity model
# increasing velocity with depth...
for i=1:grd.grsize[2]
  velmod[:,i] = 0.034 * i .+ velmod[:,i]
end

# run the traveltime computation
ttimepicks = eiktraveltime(velmod,grd,coordsrc,coordrec)</code></pre><p>The output will be a vector of vectors with 4 elements (number of sources) each of which being a 10-element array (number of receivers):</p><pre><code class="language-julia hljs">ttimepicks</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Vector{Float64}}:
 [15.680975744341035, 15.876865495861106, 16.486383772008242, 17.458808260577783, 18.715664780589695, 20.17507496205918, 21.765197285278322, 23.42860168754229, 25.121842203866873, 26.822872633110546]
 [17.523235505303774, 16.531931314497577, 15.900298808467543, 15.679473166311357, 15.899929538342748, 16.53458476827757, 17.52828824495364, 18.80099727523276, 20.271208349353397, 21.86791154817694]
 [21.764840632397313, 20.174276524595452, 18.714258547728477, 17.45664235986368, 16.483287071904506, 15.873527548487216, 15.680825879447445, 15.928244888134685, 16.584461026544158, 17.595902190523372]
 [26.715903235950208, 25.014548284522498, 23.320146712592344, 21.657909196620068, 20.07285501943066, 18.623168029848518, 17.381629855282952, 16.430677070849104, 15.848433508089691, 15.684466696648197]</code></pre><p>Now let&#39;s analyse more in details the various components.  First of we have to import the module and define the parameters of the grid using the struct <code>Grid2D</code>:</p><pre><code class="language-julia hljs">using EikonalSolvers
# hgrid: grid spacing
# cooinit: grid origin coordinates
# grsize: grid size
grd = Grid2DCart(hgrid=0.5,cooinit=(0.0,0.0),grsize=(300,220)) # create the Grid2D struct</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Grid2DCart(0.5, (0.0, 0.0), (149.5, 109.5), (300, 220), 0.0:0.5:149.5, 0.0:0.5:109.5)</code></pre><p>Then define the coordinates of the sources, a two-column array (since we are in 2D) representing the <span>$</span>x<span>$</span> and <span>$</span>y<span>$</span> coordinates</p><pre><code class="language-julia hljs">nsrc = 4
coordsrc = [grd.hgrid.*LinRange(10,290,4)   grd.hgrid.*200.0.*ones(4)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×2 Matrix{Float64}:
   5.0     100.0
  51.6667  100.0
  98.3333  100.0
 145.0     100.0</code></pre><p>and the receivers, a &quot;vector of arrays&quot;, i.e., a vector where each element (one element per each source) is a two-column array (since we are in 2D) representing the <span>$</span>x<span>$</span> and <span>$</span>y<span>$</span> coordinates</p><pre><code class="language-julia hljs">nrec = 10
coordrec = [ [grd.hgrid.*LinRange(8,294,nrec) grd.hgrid.*20.0.*ones(nrec)] for i=1:nsrc] # coordinates of the receivers (10 receivers)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Matrix{Float64}}:
 [4.0 10.0; 19.888888888888886 10.0; … ; 131.11111111111111 10.0; 147.0 10.0]
 [4.0 10.0; 19.888888888888886 10.0; … ; 131.11111111111111 10.0; 147.0 10.0]
 [4.0 10.0; 19.888888888888886 10.0; … ; 131.11111111111111 10.0; 147.0 10.0]
 [4.0 10.0; 19.888888888888886 10.0; … ; 131.11111111111111 10.0; 147.0 10.0]</code></pre><p>The velocity model is defined as a 2D array with size (<code>grd.grsize</code>)</p><pre><code class="language-julia hljs">velmod = 2.5 .* ones(grd.grsize...)
# increasing velocity with depth...
for i=1:grd.grsize[2]
  velmod[:,i] = 0.034 * i .+ velmod[:,i]
end</code></pre><p>Finally, the traveltime at receivers is computed</p><pre><code class="language-julia hljs">ttimepicks = eiktraveltime(velmod,grd,coordsrc,coordrec)</code></pre><p>Now the traveltimes can be plotted, e.g., using Makie</p><pre><code class="language-julia hljs">using CairoMakie

fig = Figure(size=(800,300))

ax1 = Axis(fig[1,1][1,1],title=&quot;Velocity model, sources and receivers&quot;,xlabel=&quot;x [Km]&quot;,ylabel=&quot;y [Km]&quot;)
hm = heatmap!(ax1,grd.x,grd.y,velmod,colormap=:rainbow1)
Colorbar(fig[1,1][1,2],hm,label=&quot;Velocity [km/s]&quot;)
for cr in coordrec
	scatter!(ax1,cr[:,1],cr[:,2],marker=:dtriangle,color=:black)
end
scatter!(ax1,coordsrc[:,1],coordsrc[:,2],marker=:circle,color=:black)
ax1.yreversed=true

ax2 = Axis(fig[1,2],title=&quot;Traveltimes&quot;,xlabel=&quot;Receiver #&quot;,ylabel=&quot;Traveltime [s]&quot;)
for (i,tt) in enumerate(ttimepicks)
	scatterlines!(ax2,1:length(tt),tt[:],label=&quot;tt src #$i&quot;)
end
axislegend(ax2)</code></pre><p><img src="images/velmod-ttpicks.png" alt="velmodttpicks"/></p><pre><code class="language-julia hljs">@show ttimepicks</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Vector{Float64}}:
 [15.680975744341035, 15.876865495861106, 16.486383772008242, 17.458808260577783, 18.715664780589695, 20.17507496205918, 21.765197285278322, 23.42860168754229, 25.121842203866873, 26.822872633110546]
 [17.523235505303774, 16.531931314497577, 15.900298808467543, 15.679473166311357, 15.899929538342748, 16.53458476827757, 17.52828824495364, 18.80099727523276, 20.271208349353397, 21.86791154817694]
 [21.764840632397313, 20.174276524595452, 18.714258547728477, 17.45664235986368, 16.483287071904506, 15.873527548487216, 15.680825879447445, 15.928244888134685, 16.584461026544158, 17.595902190523372]
 [26.715903235950208, 25.014548284522498, 23.320146712592344, 21.657909196620068, 20.07285501943066, 18.623168029848518, 17.381629855282952, 16.430677070849104, 15.848433508089691, 15.684466696648197]</code></pre><p>To additionally return the traveltime everywhere on the grid do</p><pre><code class="language-julia hljs">ttimepicks,ttimegrid = eiktraveltime(velmod,grd,coordsrc,coordrec,returntt=true)
@show size(ttimegrid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">size(ttimegrid) = (4,)</code></pre><p>The traveltime across all grid can then be visualized</p><pre><code class="language-julia hljs">using CairoMakie

fig = Figure(size=(800,300))

s = 1
ax1 = Axis(fig[1,1][1,1],title=&quot;Traveltime for source #$s&quot;,xlabel=&quot;x [Km]&quot;,ylabel=&quot;y [Km]&quot;)
hm = heatmap!(ax1,grd.x,grd.y,ttimegrid[s],colormap=:rainbow1)
Colorbar(fig[1,1][1,2],hm,label=&quot;Traveltime [s]&quot;)
contour!(ax1,grd.x,grd.y,ttimegrid[s],color=:black)
for cr in coordrec
	scatter!(ax1,cr[:,1],cr[:,2],marker=:dtriangle,color=:black)
end
scatter!(ax1,coordsrc[s,1],coordsrc[s,2],marker=:circle,color=:black)
ax1.yreversed=true

s = 3
ax2 = Axis(fig[1,2][1,1],title=&quot;Traveltime for source #$s&quot;,xlabel=&quot;x [Km]&quot;,ylabel=&quot;y [Km]&quot;)
hm = heatmap!(ax2,grd.x,grd.y,ttimegrid[s],colormap=:rainbow1)
Colorbar(fig[1,2][1,2],hm,label=&quot;Traveltime [s]&quot;)
contour!(ax2,grd.x,grd.y,ttimegrid[s],color=:black)
for cr in coordrec
	scatter!(ax2,cr[:,1],cr[:,2],marker=:dtriangle,color=:black)
end
scatter!(ax2,coordsrc[s,1],coordsrc[s,2],marker=:circle,color=:black)
ax2.yreversed=true</code></pre><p><img src="images/ttime-arrays.png" alt="ttarrays"/> The resulting traveltime array on the grid is returned as a three-dimensional array, containing a set of two-dimensional arrays, one for each source.</p><pre><code class="language-julia hljs">@show size(ttimegrid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(4,)</code></pre><h3 id="Spherical-coordinates"><a class="docs-heading-anchor" href="#Spherical-coordinates">Spherical coordinates</a><a id="Spherical-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Spherical-coordinates" title="Permalink"></a></h3><p>Here we show an example of traveltime calculation in spherical coordinates in 2D. The grid is defined in terms of the radius <code>r</code> and the angle <code>θ</code>, representing the <em>co</em>-latitude. In 3D there is the additional angle <code>φ</code>, representing the longitude. Remark: for spherical coordinates some Greek symbols are used. You can render them in Julia as following:</p><table><tr><th style="text-align: right">Symbol</th><th style="text-align: right">How to render</th></tr><tr><td style="text-align: right">Δ</td><td style="text-align: right">\Delta^TAB</td></tr><tr><td style="text-align: right">θ</td><td style="text-align: right">\theta^TAB</td></tr><tr><td style="text-align: right">φ</td><td style="text-align: right">\varphi^TAB</td></tr></table><p>The function for traveltimes in spherical coordinates, analogously to the Cartesian case, is <code>traveltime2Dsphere()</code>. The grid setup and forward computations are carried out as shown in the following script.</p><pre><code class="language-julia hljs">using EikonalSolvers
grd = Grid2DSphere(Δr=2.0,Δθ=0.2,grsize=(40,70),cooinit=(500.0,10.0)) # create the Grid2DSphere struct
coordsrc = [grd.cooinit[1].+grd.Δr*3  grd.cooinit[2].+grd.Δθ*(grd.grsize[2]-5)] # coordinates of the sources (1 source)
coordrec = [[grd.cooinit[1].+grd.Δr*(grd.grsize[1]-3) grd.cooinit[2].+grd.Δθ*3] ] # coordinates of the receivers (1 receiver), vector of arrays
velmod = 2.5 .* ones(grd.grsize...)                       # velocity model

# run the traveltime computation
ttimepicks = eiktraveltime(velmod,grd,coordsrc,coordrec)
nothing # hide</code></pre><p>The following picture shows an example of computed traveltime and gradient in spherical coordinates in 2D.  <img src="images/sph2dttgrad.png" alt="sph2dttgrad"/> </p><h2 id="Example-of-gradient-w.r.t-velocity-calculation"><a class="docs-heading-anchor" href="#Example-of-gradient-w.r.t-velocity-calculation">Example of gradient w.r.t velocity calculation</a><a id="Example-of-gradient-w.r.t-velocity-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-gradient-w.r.t-velocity-calculation" title="Permalink"></a></h2><h3 id="Cartesian-coordinates-2"><a class="docs-heading-anchor" href="#Cartesian-coordinates-2">Cartesian coordinates</a><a class="docs-heading-anchor-permalink" href="#Cartesian-coordinates-2" title="Permalink"></a></h3><p>Here a synthetic example of 2D gradient computations in Cartesian coordinates is illustrated. In reality, traveltime data are &quot;measured&quot; from recorded seismograms, however, here we first create some synthetic &quot;observed&quot; traveltimes using a synthetic velocity model. First the grid and velocity model are set up, then forward calculations are performed, as in the section above <a href="#Example-of-forward-calculations">Example of forward calculations</a>.</p><pre><code class="language-julia hljs">using EikonalSolvers
hgrid=0.5
grd = Grid2DCart(hgrid=hgrid,cooinit=(0.0,0.0),grsize=(300,220))         # create the Grid2D struct
nsrc = 4
nrec = 10
coordsrc = [0.95*hgrid.*LinRange(12,290,nsrc)   hgrid.*207.0.*ones(nsrc)] # coordinates of the sources (4 sources)
coordrec = [[hgrid.*LinRange(8.0,290.0,nrec)  hgrid.*20.0.*ones(nrec)] for i=1:nsrc] # coordinates of the receivers (10 receivers)
velmod = 2.5 .* ones(grd.grsize...)                                # velocity model
# increasing velocity with depth
for i=1:grd.grsize[2]
  velmod[:,i] = 0.034 * i .+ velmod[:,i]
end

# run the traveltime computation
ttpicks = eiktraveltime(velmod,grd,coordsrc,coordrec)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: sourceboxloctt(): Shifting the source position along dimension(s) [1] by 1.0e-5 [1e-4*grd.hgrid]
└ @ EikonalSolvers ~/work/EikonalSolvers.jl/EikonalSolvers.jl/src/EikSolv/eikmainfwd.jl:1298</code></pre><p>Then the &quot;observed&quot; traveltime data are created by adding some Gaussian noise to the traveltimes computed above to simulate real measurements.</p><pre><code class="language-julia hljs"># standard deviation of error on observed data
stdobs = [0.15.*ones(size(ttpicks[1])) for i=1:nsrc]
# generate a &quot;noise&quot; array to simulate real data
noise = [stdobs[i].^2 .* randn(size(stdobs[i])) for i=1:nsrc]
# add the noise to the synthetic traveltime data
dobs = ttpicks .+ noise</code></pre><p>Now we can finally compute the gradient of the misfit functional (see above) at a given point, i.e., the gradient is computed at a given velocity model: <span>$\dfrac{d S}{d \mathbf{v}} \Big|_{\mathbf{v}_0}$</span>.</p><pre><code class="language-julia hljs"># create a guess/&quot;current&quot; model
vel0 = 2.3 .* ones(grd.grsize...)
# increasing velocity with depth...
for i=1:grd.grsize[2]
   vel0[:,i] = 0.015 * i .+ vel0[:,i]
end

# calculate the gradient of the misfit function
gradvel,misf = eikgradient(vel0,grd,coordsrc,coordrec,dobs,stdobs,:gradvel)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: sourceboxloctt(): Shifting the source position along dimension(s) [1] by 1.0e-5 [1e-4*grd.hgrid]
└ @ EikonalSolvers ~/work/EikonalSolvers.jl/EikonalSolvers.jl/src/EikSolv/eikmainfwd.jl:1298</code></pre><p>Finally, plot the rsults </p><pre><code class="language-julia hljs">using CairoMakie

fig = Figure(size=(800,300))

ax1 = Axis(fig[1,1][1,1],title=&quot;Reference velocity model&quot;,xlabel=&quot;x [Km]&quot;,ylabel=&quot;y [Km]&quot;)
hm = heatmap!(ax1,grd.x,grd.y,vel0,colormap=:rainbow1)
Colorbar(fig[1,1][1,2],hm,label=&quot;Velocity [km/s]&quot;)
for cr in coordrec
	scatter!(ax1,cr[:,1],cr[:,2],marker=:dtriangle,color=:black)
end
scatter!(ax1,coordsrc[:,1],coordsrc[:,2],marker=:circle,color=:black)
ax1.yreversed=true

ax2 = Axis(fig[1,2][1,1],title=&quot;Gradient w.r.t. velocity&quot;,xlabel=&quot;x [Km]&quot;,ylabel=&quot;y [Km]&quot;)
vmax = maximum(abs.(gradvel))
hm = heatmap!(ax2,grd.x,grd.y,gradvel,colormap=:seismic,colorrange=(-vmax,vmax))
Colorbar(fig[1,2][1,2],hm,label=&quot;Gradient&quot;)
for cr in coordrec
	scatter!(ax2,cr[:,1],cr[:,2],marker=:dtriangle,color=:black)
end
scatter!(ax2,coordsrc[:,1],coordsrc[:,2],marker=:circle,color=:black)
ax2.yreversed=true</code></pre><p><img src="images/grad-vel.png" alt="ttarrays"/> The calculated gradient is an array with the same shape than the velocity model.</p><pre><code class="language-julia hljs">@show size(gradvel)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(300, 220)</code></pre><h3 id="Spherical-coordinates-2"><a class="docs-heading-anchor" href="#Spherical-coordinates-2">Spherical coordinates</a><a class="docs-heading-anchor-permalink" href="#Spherical-coordinates-2" title="Permalink"></a></h3><p>Here a synthetic example of 2D gradient computations in spherical coordinates is shown.</p><pre><code class="language-julia hljs">using EikonalSolvers
grd = Grid2DSphere(Δr=2.0,Δθ=0.2,grsize=(40,70),cooinit=(500.0,10.0)) # create the Grid2DSphere struct
coordsrc = [grd.cooinit[1].+grd.Δr*3  grd.cooinit[2].+grd.Δθ*(grd.grsize[2]-5)] # coordinates of the sources (1 source)
nsrc = size(coordsrc,1)
coordrec = [[grd.cooinit[1].+grd.Δr*(grd.grsize[1]-3) grd.cooinit[2].+grd.Δθ*3] for i=1:nsrc] # coordinates of the receivers (1 receiver)

# velocity model
velmod = 2.5 .* ones(grd.grsize...)
# run the traveltime computation
ttpicks = eiktraveltime(velmod,grd,coordsrc,coordrec)

# standard deviation of error on observed data
stdobs = [0.15.*ones(size(ttpicks[1])) for i=1:nsrc]
# generate a &quot;noise&quot; array to simulate real data
noise = [stdobs[i].^2 .* randn(size(stdobs[i])) for i=1:nsrc]
# add the noise to the synthetic traveltime data
dobs = ttpicks .+ noise

# create a guess/&quot;current&quot; model
vel0 = 3.0 .* ones(grd.grsize...)

# calculate the gradient of the misfit function
grad,misf = eikgradient(vel0,grd,coordsrc,coordrec,dobs,stdobs,:gradvel)
nothing # hide</code></pre><p>An example of a (thresholded) sensitivity kernel and contouring of traveltimes in 3D, using spherical coordinates, is depicted in the following plot:   <img src="images/examplegrad3Dcarsph.png" alt="grad3D"/> </p><h2 id="Example-of-gradient-w.r.t-source-location-calculation"><a class="docs-heading-anchor" href="#Example-of-gradient-w.r.t-source-location-calculation">Example of gradient w.r.t source location calculation</a><a id="Example-of-gradient-w.r.t-source-location-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-gradient-w.r.t-source-location-calculation" title="Permalink"></a></h2><p>Here a synthetic example of 2D gradient computation w.r.t. source location in Cartesian coordinates is illustrated. In reality, traveltime data are &quot;measured&quot; from recorded seismograms, however, here we first create some synthetic &quot;observed&quot; traveltimes using a given velocity model. First the grid and velocity model are set up, then forward calculations are performed, as in the section above <a href="#Example-of-forward-calculations">Example of forward calculations</a>.</p><pre><code class="language-julia hljs">using EikonalSolvers
hgrid=0.5
grd = Grid2DCart(hgrid=hgrid,cooinit=(0.0,0.0),grsize=(300,220))         # create the Grid2D struct
nsrc = 4
nrec = 10
coordsrc = [0.95*hgrid.*LinRange(12,290,nsrc)   hgrid.*207.0.*ones(nsrc)] # coordinates of the sources (4 sources)
coordrec = [[hgrid.*LinRange(8.0,290.0,nrec)  hgrid.*20.0.*ones(nrec)] for i=1:nsrc] # coordinates of the receivers (10 receivers)
velmod = 2.5 .* ones(grd.grsize...)                                # velocity model
# increasing velocity with depth
for i=1:grd.grsize[2]
  velmod[:,i] = 0.034 * i .+ velmod[:,i]
end

# run the traveltime computation
ttpicks = eiktraveltime(velmod,grd,coordsrc,coordrec)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: sourceboxloctt(): Shifting the source position along dimension(s) [1] by 1.0e-5 [1e-4*grd.hgrid]
└ @ EikonalSolvers ~/work/EikonalSolvers.jl/EikonalSolvers.jl/src/EikSolv/eikmainfwd.jl:1298</code></pre><p>Then the &quot;observed&quot; traveltime data are created by adding some Gaussian noise to the traveltimes computed above to simulate real measurements.</p><pre><code class="language-julia hljs"># standard deviation of error on observed data
stdobs = [0.15.*ones(size(ttpicks[1])) for i=1:nsrc]
# generate a &quot;noise&quot; array to simulate real data
noise = [stdobs[i].^2 .* randn(size(stdobs[i])) for i=1:nsrc]
# add the noise to the synthetic traveltime data
dobs = ttpicks .+ noise</code></pre><p>Now the gradient w.r.t. source location, <span>$\dfrac{d S}{d \mathbf{x}^{\rm src}}$</span>, can be computed as follows</p><pre><code class="language-julia hljs"># calculate the gradient of the misfit function w.r.t. source location
#   notice the last argument :gradsrcloc
gradsrcloc,misf = eikgradient(velmod,grd,coordsrc,coordrec,dobs,stdobs,:gradsrcloc)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: sourceboxloctt(): Shifting the source position along dimension(s) [1] by 1.0e-5 [1e-4*grd.hgrid]
└ @ EikonalSolvers ~/work/EikonalSolvers.jl/EikonalSolvers.jl/src/EikSolv/eikmainfwd.jl:1298</code></pre><p>The gradient is returned as an array where each row contains the partial derivatives for each source:</p><pre><code class="language-julia hljs"># now print the partial derivatives
@show(gradsrcloc)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×2 Matrix{Float64}:
  0.120882    0.0779432
  0.0598656   0.152987
 -0.0607007   0.0446767
 -0.565001   -0.630783</code></pre><h1 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h1><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-ZuninoGebraadetal2023"><a class="tag is-link" href="#citeref-ZuninoGebraadetal2023">ZuninoGebraadetal2023</a>Zunino A., Gebraad, L., Ghirotto, A. and Fichtner, A., (2023). HMCLab a framework for solving diverse geophysical inverse problems using the Hamiltonian Monte Carlo algorithm, Geophysical Journal International, Volume 235, Issue 3, December 2023, Pages 2979–2991, https://doi.org/10.1093/gji/ggad403.</li><li class="footnote" id="footnote-Zuninoetal2025"><a class="tag is-link" href="#citeref-Zuninoetal2025">Zuninoetal2025</a>Andrea Zunino, Scott Keating, Andreas Fichtner (2025), **A discrete adjoint method for deterministic and probabilistic eikonal-equation-based inversion of traveltime for velocity and source location, arXiv preprint arXiv:2501.13532.</li><li class="footnote" id="footnote-LeungQian2006"><a class="tag is-link" href="#citeref-LeungQian2006">LeungQian2006</a>Leung, S. and Qian, J. (2006). An adjoint state method for three-dimensional transmission traveltime tomography using first-arrivals. Communications in Mathematical Sciences, 4(1), 249-266.</li><li class="footnote" id="footnote-TreisterHaber2016"><a class="tag is-link" href="#citeref-TreisterHaber2016">TreisterHaber2016</a>Treister, Eran &amp; Haber, Eldad. (2016). A fast marching algorithm for the factored eikonal equation. Journal of Computational Physics. 324. 210–225. 10.1016/j.jcp.2016.08.012. </li><li class="footnote" id="footnote-RawlinsonSambridge2004"><a class="tag is-link" href="#citeref-RawlinsonSambridge2004">RawlinsonSambridge2004</a>Rawlinson, N. and Sambridge, M. (2004). Wave front evolution in strongly heterogeneous layered media using the fast marching method. Geophys. J. Int., 156(3), 631-647.</li><li class="footnote" id="footnote-Sethian1996"><a class="tag is-link" href="#citeref-Sethian1996">Sethian1996</a>Sethian A. J. (1996). A fast marching level set method for monotonically advancing fronts. Proceedings of the National Academy of Sciences Feb 1996, 93 (4) 1591-1595. </li><li class="footnote" id="footnote-SethianPopovici1999"><a class="tag is-link" href="#citeref-SethianPopovici1999">SethianPopovici1999</a>Sethian A. J. and Popovici A. (1999). Three dimensional traveltimes computation using the Fast Marching Method. Geophysics. 64. 516-523. </li><li class="footnote" id="footnote-ZuninoMosegaard2018"><a class="tag is-link" href="#citeref-ZuninoMosegaard2018">ZuninoMosegaard2018</a>Zunino A., Mosegaard K. (2018), Integrating Gradient Information with Probabilistic Traveltime Tomography Using the Hamiltonian Monte Carlo Algorithm, 80th EAGE Conference &amp; Exhibition, Copenhagen.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="publicapi/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 21 October 2025 15:01">Tuesday 21 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
